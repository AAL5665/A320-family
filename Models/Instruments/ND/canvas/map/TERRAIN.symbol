# See: http://wiki.flightgear.org/MapStructure
# Class things:
var name = 'TERRAIN';
var parents = [DotSym];
var __self__ = caller(0)[0];
DotSym.makeinstance( name, __self__ );

var element_type = "group";

var tile_list = ["*black*","tile_01.png","tile_02.png","tile_03.png","tile_04.png","tile_06.png","tile_09.png"];

var radar_beacon = 0;
var radar_cycle = 0;
var rader_cleared = 0;

var get_elevation = func (lat, lon) {

	var info = geodinfo(lat, lon);
	var elevation = 0;
	if (info != nil) { elevation = int(info[0] * 3.2808399); }
	else { elevation = nil; }
	return elevation;

}


var updateTerrain = func(r_scaled){

	if(me.fetching) return;

	me.fetching = 1;
	me.rader_cleared = 0;

	var RAD2DEG = 57.2957795;
	var DEG2RAD = 0.016774532925;

	var pos = geo.aircraft_position();
	var pos_lat = pos.lat();
	var pos_lon = pos.lon();
	
	var heading = getprop("orientation/heading-magnetic-deg");
	var altitudeagl = getprop("/position/altitude-agl-ft");

	var side = (math.mod(me.radar_beacon,2)==0) ? "L" : "R";
	var a = int(me.radar_beacon/2);
    var col = a;

	if (side == "R") {
		col = -1 + (-1 * a);
	}

	#var col = me.radar_beacon - me.tileradius;

	#for (var a=0; a < me.tileradius; a+=1) {

		#var trnL = me.terrlayer["L" ~ a];
		#var trnR = me.terrlayer["R" ~ a];
		var trn = me.terrlayer[side ~ a];

		var len = size(trn);
		var range = me.range;

		var tiles = me.tile_list;

		var proj_lon = pos_lon + ((col * (range/30) * math.sin(DEG2RAD * (heading - 90))) / 60);
		var proj_lat = pos_lat + ((col * (range/30) * math.cos(DEG2RAD * (heading - 90))) / 60);

		var elevft = [];

		for (var row = 0; row <= len; row += 1) {

			var point_lon = proj_lon + ((row * (range/30) / 60) * math.sin(DEG2RAD * heading));
			var point_lat = proj_lat + ((row * (range/30) / 60) * math.cos(DEG2RAD * heading));

			var elev = me.get_elevation(point_lat, point_lon);
			var grad = 0; #black
			if (elev != nil) {
				var diff = elev - altitudeagl;
				if (diff>=0) {
					grad = int(diff/1000) + 3;
					if (grad>5) grad = 5;
				} else {
					if (diff<500) grad = 3; # lite yellowe
					else {
						grad = 2 + int(diff/1000);
						if (grad<0) grad = 0;
					}
				}
				append(elevft,grad); # 0-5
			} else {
				append(elevft,6);  # magenta
			}
			
		}

		for (var r=0; r < len; r+=1) {

			var imgx = elevft[r];
			if (imgx < 1) trn[r].hide();
			else trn[r].setFile(me.imgpath ~ me.tile_list[imgx]).show();
			#trnR[r].setFile(me.imgpath ~ me.tile_list[2-imgx]).show();

		}

	#}

	me.radar_beacon += 1;
	if (me.radar_beacon >= (me.tileradius*2)) {
		me.radar_beacon = 0;
		me.radar_cycle += 1;
	}

	#me.last_request = getprop("sim/time/elapsed-sec");
	me.fetching = 0;
};

var init = func {
	#print('TERRAIN init');
	me.tile = 33; # better 34
	me.fetching = 0;
	me.timeStamp = nil;
	me.fetchRad = me.model.fetchRad; # Radius of radar layer to fetch
	me.range = me.model.rangeNm; # Range of Navigation Display
	me.viewport_radius = me.getOption('viewport_radius', 670);
	me.imgpath = get_local_path('res/terrain/');
	me.rader_cleared = 1;

	var tile = me.tile;

	var gx = int(me.viewport_radius / tile);

	me.tileradius = gx;

	me.terrlayer = {}; #me.element.createChild("image").set("z-index", -100).hide();

	var centx = 0; #me.viewport_radius * -0.5;
	var centy = -me.viewport_radius;

	for (var c=0; c<gx; c+=1) {
		var hh = c * tile;
		var mx = (c == 0) ? gx : int(math.sqrt(gx*gx-c*c) + 0.5);
		var py = centy + (gx-1) * tile;
		var pxr = centx+(c*tile);
		var pxl = centx-(c*tile)-tile;
		var grplx = [];
		var grprx = [];
		for (var r=0; r<mx; r+=1) {
			append(grplx , me.element.createChild("image").set("z-index", -100).setSize(tile,tile).setTranslation(pxl,py).hide());
			append(grprx , me.element.createChild("image").set("z-index", -100).setSize(tile,tile).setTranslation(pxr,py).hide());
			py-=tile;
		}
		me.terrlayer["L" ~ c] = grplx;
		me.terrlayer["R" ~ c] = grprx;
	}
		
	me.update_interval = 300;
	me.last_request = 0;
	
	#var r_scaled = (me.fetchRad*me.viewport_radius)/me.range;
	#me.fetchWXRMap(r_scaled);
	
	#me.timeStamp = nil;
	#http.load("https://api.rainviewer.com/public/maps.json").done(func(r) me.timeStamp = processRequest(r));
};

var clear = func {

	if (me.rader_cleared == 0) {
		for (var c=0; c<me.tileradius; c+=1 ) {
			var rowL = me.terrlayer["L" ~ c];
			var rowR = me.terrlayer["R" ~ c];
			var len = size(rowL);
			for (var r=0; r<len; r+=1) {
				rowL[r].hide();
				rowR[r].hide();
			}		
		}	
		me.rader_cleared = 1;
	}

}

var draw = func {
	var range = me.layer.map.getRange(); # Range of Navigation Display
	var update_size = (range != me.range);
	me.range = range;
	me.fetchRad = me.model.fetchRad; # Radius of radar layer to fetch
	var r_scaled = (me.fetchRad*me.viewport_radius)/me.range;
	#var hdg = me.layer.map.getHdg();
	#var rot = 0 - hdg;
	#if(rot < 0) rot = 360 + rot + -getprop("/environment/magnetic-variation-deg"); 
	#me.element.setRotation(rot*D2R);
	if(update_size){
		me.clear();
		#me.terrlayer.hide();
		#me.terrlayer.setSize(2*r_scaled, 2*r_scaled)
		#		  .setTranslation(-r_scaled, -r_scaled);
		#me.terrlayer.show();
	}

	var rot = getprop("orientation/heading-deg");
	rot -= me.layer.map.getHdg();
	me.element.setRotation(rot*D2R);


	#if(getprop("sim/time/elapsed-sec") - me.last_request >= me.update_interval) {
		me.updateTerrain(r_scaled);
	#}
};

