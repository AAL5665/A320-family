# See: http://wiki.flightgear.org/MapStructure
# Class things:
var name = 'TERRAIN';
var parents = [DotSym];
var __self__ = caller(0)[0];
DotSym.makeinstance( name, __self__ );

var element_type = "group";

var terrain_minalt = props.globals.initNode("/custom/terrain/min-altitude", 0,"INT");
var terrain_maxalt = props.globals.initNode("/custom/terrain/max-altitude", -9999,"INT");

var tile_list = ["*black*","tile_01.png","tile_02.png","tile_03.png","tile_04.png","tile_06.png","tile_09.png","tile_s1.png"];

var is_terrain = 0;

var get_elevation = func (lat, lon) {
	var info = geodinfo(lat, lon);
	var elevation = 0;
	if (info != nil) { 
		elevation = int(info[0] * 3.2808399);
		me.is_terrain = (info[1] == nil) ? 1 : info[1].solid;
    }
	else { elevation = nil; }
	return elevation;
}

var updateTerrain = func {

	if (me.reference == nil) return;

	if(me.fetching) return;

	me.fetching = 1;

	if (me.request_clear == 1) {
		me.request_clear = 0;
		me.clear();
	}

	var RAD2DEG = 57.2957795;
	var DEG2RAD = 0.016774532925;

	var pos_lat = me.reference.lat();
	var pos_lon = me.reference.lon();
	
	var heading = me.reference.heading;
	var altitudeft = me.reference.altitudeft;

	var side = (math.mod(me.radar_beacon,2)==0) ? "L" : "R";
	var a = int(me.radar_beacon/2);
    var col = a;

	if (side == "R") {
		col = -1 + (-1 * a);
	}

	var trn = me.terrlayer[side ~ a];

	var len = size(trn);
	var range = me.range;

	var tiles = me.tile_list;

	var proj_lon = pos_lon + ((col * (range/30) * math.sin(DEG2RAD * (heading - 90))) / 40);
	var proj_lat = pos_lat + ((col * (range/30) * math.cos(DEG2RAD * (heading - 90))) / 40);

	var elevft = [];

	for (var row = 0; row < len; row += 1) {

		if (trn[row] == nil) {
			append(elevft,-1);
			continue;
		}

		var point_lon = proj_lon + ((row * (range/30) / 40) * math.sin(DEG2RAD * heading));
		var point_lat = proj_lat + ((row * (range/30) / 40) * math.cos(DEG2RAD * heading));

		var elev = me.get_elevation(point_lat, point_lon);
		var grad = 0; #black
		if (elev != nil) {
			if (me.is_terrain) {			
				if (elev<me.min_altitude) me.min_altitude = elev;
				else if (elev>me.max_altitude) me.max_altitude = elev;
				if (elev < me.basealtitudeft) grad = 0; # < 400 near runway use blank
				else {
					var diff = elev - altitudeft;
					if (diff>=0) {
						grad = int(diff/1000) + 3;
						if (grad>5) grad = 5;
					} else {
						if (diff>-500) grad = 3; # lite yellow
						else {
							grad = 2 + int(diff/1000);
							if (grad<0) grad = 0;
						}						
					}
				}
			} else {
				var diff = elev - altitudeft;
				if (diff>=-2000) grad = 7; #sea
			}
			append(elevft,grad); # 0-5
		} else {
			append(elevft,6);  # magenta
		}
		
	}

	me.radar_cleared = 0;

	for (var r=0; r < len; r+=1) {
		var imgx = elevft[r];
		if (imgx == -1) continue;			
		if (imgx < 1) trn[r].hide();
		else trn[r].setFile(me.imgpath ~ me.tile_list[imgx]).show();		
	}

	me.radar_beacon += 1;
	if (me.radar_beacon >= (me.tileradiusw*2)) {
		me.update_altitudes();
		me.restart_beacon();
	}

	#me.last_request = getprop("sim/time/elapsed-sec");
	me.fetching = 0;
};

var update_altitudes = func {
	me.terrain_minalt.setValue(me.min_altitude);
	me.terrain_maxalt.setValue(me.max_altitude);
}

var restart_beacon = func {
	me.radar_beacon = 0;
	me.radar_cycle += 1;
	me.min_altitude = 9999;
	me.max_altitude = -9999;
};

var init = func {
	#print('TERRAIN init');
	me.tile = 33; # preferred 34
	me.fetching = 0;
	me.timeStamp = nil;
	me.fetchRad = me.model.fetchRad; # Radius of radar layer to fetch
	me.range = me.model.rangeNm; # Range of Navigation Display
	me.viewport_radius = me.getOption('viewport_radius', 670);
	me.imgpath = get_local_path('res/terrain/');
	me.radar_beacon = 0;
	me.radar_cycle = 0;
	me.radar_cleared = 1;
	me.request_clear = 0;
	me.visible = 0;
	me.min_altitude = 9999;
	me.max_altitude = -9999;
	me.basealtitudeft = nil;
	me.reference = nil;
	me.onfailure = 0;

	var tile = me.tile;

	var gx = int(me.viewport_radius / tile);
	me.tileradius = gx;

	var limx = int((512/tile)+0.5);  # horiz space is smaller
	me.tileradiusw = limx;

	me.terrlayer = {};

	var centx = 0;
	var centy = -me.viewport_radius;

	var group = me.group.createChild("group").set("z-index", -100); #me.element

	for (var c=0; c<limx; c+=1) {
		var hh = c * tile;
		var mx = (c == 0) ? gx : int(math.sqrt(gx*gx-c*c) + 0.5);
		var my = int(c*4/gx);
		var py = centy + (gx-1) * tile;
		var pxr = centx+(c*tile);
		var pxl = centx-(c*tile)-tile;
		var grplx = [];
		var grprx = [];
		for (var r=0; r<mx; r+=1) {
			if (r<my) {
				append(grplx , nil); #skip
				append(grprx , nil);
			} else {
				append(grplx , group.createChild("image").setSize(tile,tile).setTranslation(pxl,py).hide());
				append(grprx , group.createChild("image").setSize(tile,tile).setTranslation(pxr,py).hide());
			}
			py-=tile;
		}
		me.terrlayer["L" ~ c] = grplx;
		me.terrlayer["R" ~ c] = grprx;
	}
		
	setlistener("/controls/switches/terr_on_nd_l", func{
		me.request_clear = 1;
	});

	setlistener("/ECAM/warnings/timer/nav-gpws-terr-fault", func{
		me.onfailure = getprop("/ECAM/warnings/timer/nav-gpws-terr-fault");
	});

};

var clear = func {

	if (me.radar_cleared == 0) {
		me.radar_cleared = 1;
		for (var c=0; c<me.tileradiusw; c+=1 ) {
			var rowL = me.terrlayer["L" ~ c];			
			var rowR = me.terrlayer["R" ~ c];
			var len = size(rowL);
			for (var r=0; r<len; r+=1) {
				if (rowL[r] != nil) {
					rowL[r].hide();
					rowR[r].hide();
				}
			}
		}		
	}

}

var draw = func {

	if(me.fetching) return;

    if (me.onfailure == 1) {
		me.clear();
		me.restart_beacon();
		return;
	}

	if (me.radar_beacon == 0) {  # update aircraft reference

		var ref = geo.aircraft_position();
		me.reference = ref;
		if (ref != nil) {
			me.reference.heading = getprop("orientation/heading-magnetic-deg");
			me.reference.altitudeft = ref.alt() * 3.2808399;

			if (me.basealtitudeft == nil) {
				#var basealtft = me.get_elevation(ref.lat,ref.lon);
				var basealtft = ref.alt() * 3.2808399;
				if (basealtft == nil) basealtft = 0;
				me.basealtitudeft = basealtft + 400;
			}

			#if (fmgc.FMGCInternal.phase >= 5 and me.basealtitudeft == 0) {
			#	var basealtft = me.get_elevation(ref.lat,ref.lon);
			#	if (basealtft == nil) basealtft = 0;
			#	me.basealtitudeft = basealtft + 400;
			#	#	me.reference.basealtitudeft = ft + 400  # <- TODO get departure/arrival runway altitude
			#} 
			#else if ((fmgc.FMGCInternal.phase > 1 and fmgc.FMGCInternal.phase < 5) and (me.basealtitudeft != 0)) {
			#	me.basealtitudeft = 0;
			#}

		}
	}

	var range = me.layer.map.getRange(); # Range of Navigation Display
	var update_size = (range != me.range);
	me.range = range;

	if(update_size){
		me.request_clear = 1;
	}

	me.updateTerrain(); # left
	if (math.mod(me.radar_beacon,2)==1) me.updateTerrain(); # right

};
