# See: http://wiki.flightgear.org/MapStructure
# Class things:
var name = 'TERRAIN';
var parents = [DotSym];
var __self__ = caller(0)[0];
DotSym.makeinstance( name, __self__ );

var element_type = "group";

var tile_list = ["*black*","tile_01.png","tile_02.png","tile_03.png","tile_04.png","tile_06.png","tile_09.png"];

var radar_beacon = 0;
var radar_cycle = 0;
var rader_cleared = 0;

var get_elevation = func (lat, lon) {

	var info = geodinfo(lat, lon);
	var elevation = 0;
	if (info != nil) { elevation = int(info[0] * 3.2808399); }
	else { elevation = nil; }
	return elevation;

}

var updateTerrain = func(r_scaled){

	if(me.fetching) return;

	me.fetching = 1;
	me.rader_cleared = 0;

	var RAD2DEG = 57.2957795;
	var DEG2RAD = 0.016774532925;

	var pos = geo.aircraft_position();
	var pos_lat = pos.lat();
	var pos_lon = pos.lon();
	
	var heading = getprop("orientation/heading-magnetic-deg");
	var altitudeft = pos.alt() * 3.2808399;

	if (me.basealtitudeft == nil) {
		var basealtft = me.get_elevation(pos_lat,pos_lon);
		if (basealtft == nil) basealtft = 0;
		me.basealtitudeft = basealtft + 400;
	}

	var side = (math.mod(me.radar_beacon,2)==0) ? "L" : "R";
	var a = int(me.radar_beacon/2);
    var col = a;

	if (side == "R") {
		col = -1 + (-1 * a);
	}

	#var col = me.radar_beacon - me.tileradius;

	#for (var a=0; a < me.tileradius; a+=1) {

		#var trnL = me.terrlayer["L" ~ a];
		#var trnR = me.terrlayer["R" ~ a];
		var trn = me.terrlayer[side ~ a];

		var len = size(trn);
		var range = me.range;

		var tiles = me.tile_list;

		var proj_lon = pos_lon + ((col * (range/30) * math.sin(DEG2RAD * (heading - 90))) / 30);
		var proj_lat = pos_lat + ((col * (range/30) * math.cos(DEG2RAD * (heading - 90))) / 30);

		var elevft = [];

		for (var row = 0; row <= len; row += 1) {

			var point_lon = proj_lon + ((row * (range/30) / 30) * math.sin(DEG2RAD * heading));
			var point_lat = proj_lat + ((row * (range/30) / 30) * math.cos(DEG2RAD * heading));

			var elev = me.get_elevation(point_lat, point_lon);
			var grad = 0; #black
			if (elev != nil) {
				if (elev < me.basealtitudeft) grad = 0; # < 400 (at airport) use blank - trivial
				else {
					var diff = elev - altitudeft;
					if (diff>=0) {
						grad = int(diff/1000) + 3;
						if (grad>5) grad = 5;
					} else {
						if (diff>-500) grad = 3; # lite yellow
						else {
							grad = 2 + int(diff/1000);
							if (grad<0) grad = 0;
						}
					}
				}
				append(elevft,grad); # 0-5
			} else {
				append(elevft,6);  # magenta
			}
			
		}

		for (var r=0; r < len; r+=1) {

			var imgx = elevft[r];
			if (imgx < 1) trn[r].hide();
			else trn[r].setFile(me.imgpath ~ me.tile_list[imgx]).show();
			#trnR[r].setFile(me.imgpath ~ me.tile_list[2-imgx]).show();

		}

	#}

	me.radar_beacon += 1;
	if (me.radar_beacon >= (me.tileradius*2)) {
		me.radar_beacon = 0;
		me.radar_cycle += 1;
	}

	#me.last_request = getprop("sim/time/elapsed-sec");
	me.fetching = 0;
};

var init = func {
	#print('TERRAIN init');
	me.tile = 33; # preferred 34
	me.fetching = 0;
	me.timeStamp = nil;
	me.fetchRad = me.model.fetchRad; # Radius of radar layer to fetch
	me.range = me.model.rangeNm; # Range of Navigation Display
	me.viewport_radius = me.getOption('viewport_radius', 670);
	me.imgpath = get_local_path('res/terrain/');
	me.rader_cleared = 1;
	me.basealtitudeft = nil;
	me.visible = 0;

	var tile = me.tile;

	var gx = int(me.viewport_radius / tile);

	me.tileradius = gx;

	me.terrlayer = {}; #me.element.createChild("image").set("z-index", -100).hide();

	var centx = 0; #me.viewport_radius * -0.5;
	var centy = -me.viewport_radius;

	var group = me.group.createChild("group").set("z-index", -100); #me.element

	for (var c=0; c<gx; c+=1) {
		var hh = c * tile;
		var mx = (c == 0) ? gx : int(math.sqrt(gx*gx-c*c) + 0.5);
		var py = centy + (gx-1) * tile;
		var pxr = centx+(c*tile);
		var pxl = centx-(c*tile)-tile;
		var grplx = [];
		var grprx = [];
		for (var r=0; r<mx; r+=1) {
			append(grplx , group.createChild("image").setSize(tile,tile).setTranslation(pxl,py).hide()); #.set("z-index", -100)
			append(grprx , group.createChild("image").setSize(tile,tile).setTranslation(pxr,py).hide()); #.set("z-index", -100)
			py-=tile;
		}
		me.terrlayer["L" ~ c] = grplx;
		me.terrlayer["R" ~ c] = grprx;
	}
		
	me.update_interval = 300;
	me.last_request = 0;
	
	#var r_scaled = (me.fetchRad*me.viewport_radius)/me.range;
	#me.fetchWXRMap(r_scaled);
	
	#me.timeStamp = nil;
	#http.load("https://api.rainviewer.com/public/maps.json").done(func(r) me.timeStamp = processRequest(r));
};

var clear = func {

	if (me.rader_cleared == 0) {
		for (var c=0; c<me.tileradius; c+=1 ) {
			var rowL = me.terrlayer["L" ~ c];
			var rowR = me.terrlayer["R" ~ c];
			var len = size(rowL);
			for (var r=0; r<len; r+=1) {
				rowL[r].hide();
				rowR[r].hide();
			}		
		}	
		me.rader_cleared = 1;
	}

}

var draw = func {
	
	var range = me.layer.map.getRange(); # Range of Navigation Display
	var update_size = (range != me.range);
	me.range = range;
	me.fetchRad = me.model.fetchRad; # Radius of radar layer to fetch
	var r_scaled = (me.fetchRad*me.viewport_radius)/me.range;

	var update_visible = (me.group.getVisible() != me.visible);

	if(update_size or update_visible){
		me.clear();
		me.visible = me.group.getVisible();
	}

	#var rot = getprop("orientation/heading-deg");
	#rot -= me.layer.map.getHdg();
	#me.element.setRotation(rot*D2R);

	me.updateTerrain(r_scaled);

};

