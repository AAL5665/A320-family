# See: http://wiki.flightgear.org/MapStructure
# Class things:
var name = 'TERRAIN';
var parents = [DotSym];
var __self__ = caller(0)[0];
DotSym.makeinstance( name, __self__ );

var element_type = "group";

var terrain_visible = props.globals.initNode("/custom/terrain/visible", 0,"INT");
var terrain_minalt = props.globals.initNode("/custom/terrain/min-altitude", 0,"INT");
var terrain_maxalt = props.globals.initNode("/custom/terrain/max-altitude", -9999,"INT");

var tile_list = ["*black*","tile_01.png","tile_02.png","tile_03.png","tile_04.png","tile_06.png","tile_09.png"];


var get_elevation = func (lat, lon) {
	var info = geodinfo(lat, lon);
	var elevation = 0;
	if (info != nil) { elevation = int(info[0] * 3.2808399); }
	else { elevation = nil; }
	return elevation;
}

var updateTerrain = func(r_scaled){

	if(me.fetching) return;

	me.fetching = 1;

	if (me.request_clear == 1) {
		me.request_clear = 0;
		me.clear();
	}

	var RAD2DEG = 57.2957795;
	var DEG2RAD = 0.016774532925;

	var pos = geo.aircraft_position();
	var pos_lat = pos.lat();
	var pos_lon = pos.lon();
	
	var heading = getprop("orientation/heading-magnetic-deg");
	var altitudeft = pos.alt() * 3.2808399;

	if (me.basealtitudeft == nil) {
		var basealtft = me.get_elevation(pos_lat,pos_lon);
		if (basealtft == nil) basealtft = 0;
		me.basealtitudeft = basealtft + 400;
	}

	var side = (math.mod(me.radar_beacon,2)==0) ? "L" : "R";
	var a = int(me.radar_beacon/2);
    var col = a;

	if (side == "R") {
		col = -1 + (-1 * a);
	}

	var trn = me.terrlayer[side ~ a];

	var len = size(trn);
	var range = me.range;

	var tiles = me.tile_list;

	var proj_lon = pos_lon + ((col * (range/30) * math.sin(DEG2RAD * (heading - 90))) / 40);
	var proj_lat = pos_lat + ((col * (range/30) * math.cos(DEG2RAD * (heading - 90))) / 40);

	var elevft = [];

	for (var row = 0; row < len; row += 1) {

		if (trn[row] == nil) {
			append(elevft,-1);
			continue;
		}

		var point_lon = proj_lon + ((row * (range/30) / 40) * math.sin(DEG2RAD * heading));
		var point_lat = proj_lat + ((row * (range/30) / 40) * math.cos(DEG2RAD * heading));

		var elev = me.get_elevation(point_lat, point_lon);
		var grad = 0; #black
		if (elev != nil) {
			if (elev<me.min_altitude) me.min_altitude = elev;
			else if (elev>me.max_altitude) me.max_altitude = elev;
			if (elev < me.basealtitudeft) grad = 0; # < 400 (at airport) use blank - trivial
			else {
				var diff = elev - altitudeft;
				if (diff>=0) {
					grad = int(diff/1000) + 3;
					if (grad>5) grad = 5;
				} else {
					if (diff>-500) grad = 3; # lite yellow
					else {
						grad = 2 + int(diff/1000);
						if (grad<0) grad = 0;
					}
				}
			}
			append(elevft,grad); # 0-5
		} else {
			append(elevft,6);  # magenta
		}
		
	}

	me.radar_cleared = 0;

	for (var r=0; r < len; r+=1) {
		var imgx = elevft[r];
		if (imgx == -1) continue;			
		if (imgx < 1) trn[r].hide();
		else trn[r].setFile(me.imgpath ~ me.tile_list[imgx]).show();		
	}

	me.radar_beacon += 1;
	if (me.radar_beacon >= (me.tileradiusw*2)) {
		me.update_altitudes();
		me.restart_beacon();
	}

	#me.last_request = getprop("sim/time/elapsed-sec");
	me.fetching = 0;
};

var update_altitudes = func {
	me.terrain_minalt.setValue(me.min_altitude);
	me.terrain_maxalt.setValue(me.max_altitude);
}

var restart_beacon = func {
	me.radar_beacon = 0;
	me.radar_cycle += 1;
	me.min_altitude = 9999;
	me.max_altitude = -9999;
};

var init = func {
	#print('TERRAIN init');
	me.tile = 33; # preferred 34
	me.fetching = 0;
	me.timeStamp = nil;
	me.fetchRad = me.model.fetchRad; # Radius of radar layer to fetch
	me.range = me.model.rangeNm; # Range of Navigation Display
	me.viewport_radius = me.getOption('viewport_radius', 670);
	me.imgpath = get_local_path('res/terrain/');
	me.radar_beacon = 0;
	me.radar_cycle = 0;
	me.radar_cleared = 1;
	me.request_clear = 0;
	me.basealtitudeft = nil;
	me.visible = 0;
	me.min_altitude = 9999;
	me.max_altitude = -9999;

	var tile = me.tile;

	var gx = int(me.viewport_radius / tile);
	me.tileradius = gx;

	var limx = int((512/tile)+0.5);  # horiz space is smaller
	me.tileradiusw = limx;

	me.terrlayer = {};

	var centx = 0;
	var centy = -me.viewport_radius;

	var group = me.group.createChild("group").set("z-index", -100); #me.element

	for (var c=0; c<limx; c+=1) {
		var hh = c * tile;
		var mx = (c == 0) ? gx : int(math.sqrt(gx*gx-c*c) + 0.5);
		var my = int(c*4/gx);
		var py = centy + (gx-1) * tile;
		var pxr = centx+(c*tile);
		var pxl = centx-(c*tile)-tile;
		var grplx = [];
		var grprx = [];
		for (var r=0; r<mx; r+=1) {
			if (r<my) {
				append(grplx , nil); #skip
				append(grprx , nil);
			} else {
				append(grplx , group.createChild("image").setSize(tile,tile).setTranslation(pxl,py).hide());
				append(grprx , group.createChild("image").setSize(tile,tile).setTranslation(pxr,py).hide());
			}
			py-=tile;
		}
		me.terrlayer["L" ~ c] = grplx;
		me.terrlayer["R" ~ c] = grprx;
	}
		
	#me.update_interval = 300;
	#me.last_request = 0;

	#var r_scaled = (me.fetchRad*me.viewport_radius)/me.range;
	#me.fetchWXRMap(r_scaled);
	
	#me.timeStamp = nil;
	#http.load("https://api.rainviewer.com/public/maps.json").done(func(r) me.timeStamp = processRequest(r));
};

var clear = func {

	if (me.radar_cleared == 0) {
		me.radar_cleared = 1;
		for (var c=0; c<me.tileradiusw; c+=1 ) {
			var rowL = me.terrlayer["L" ~ c];			
			var rowR = me.terrlayer["R" ~ c];
			var len = size(rowL);
			for (var r=0; r<len; r+=1) {
				if (rowL[r] != nil) {
					rowL[r].hide();
					rowR[r].hide();
				}
			}
		}		
	}

}

var draw = func {

	if(me.fetching) return;
	
	var range = me.layer.map.getRange(); # Range of Navigation Display
	var update_size = (range != me.range);
	me.range = range;
	me.fetchRad = me.model.fetchRad; # Radius of radar layer to fetch
	var r_scaled = (me.fetchRad*me.viewport_radius)/me.range;

	if(update_size){
		me.request_clear = 1;
	}

	if(me.terrain_visible.getValue() == 0){
		me.request_clear = 1;
		me.terrain_visible.setValue(1);
	}

	me.updateTerrain(r_scaled); # left
	if (math.mod(me.radar_beacon,2)==1) me.updateTerrain(r_scaled); # right

};
